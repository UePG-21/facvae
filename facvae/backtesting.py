import numpy as np
import pandas as pd
from matplotlib import pyplot as plt


def _calc_nv_mdd(
    rets: pd.Series, recovery_thresh: float = 0.0
) -> tuple[pd.Series, dict]:
    """Calculate net value and maximum drawdown

    Parameters
    ----------
    rets : pd.Series
        Returns
    recovery_thresh : float, optional
        Threshold to determine a recovery after reaching the mdd, by default 0.0

    Returns
    -------
    tuple[pd.Series, dict]
        pd.Series
            Net values
        dict
            Relative indicators about maximum drawdown
    """
    # net values (using simple interest)
    nvs = 1 + rets.cumsum()
    # nv value rolling max
    nvs_rolling_max = nvs.cummax()
    # drawdown
    dd = (nvs - nvs_rolling_max) / nvs_rolling_max
    # maximum drawdown
    mdd = dd.min()
    # mdd key timestamps
    if mdd:
        mdd_end_ts = dd.idxmin()
        mdd_start_ts = nvs.loc[:mdd_end_ts].idxmax()
        recovery = dd.loc[mdd_end_ts:]
        try:
            recovery_ts = recovery[recovery >= -recovery_thresh].index[0]
            recovery_period = recovery_ts - mdd_start_ts
        except:
            recovery_ts, recovery_period = None, None
    else:
        mdd_start_ts = None
        mdd_end_ts = None
        recovery_ts = None
        recovery_period = None
    # load values
    dict_mdd = {
        "mdd": mdd,
        "mdd_start_ts": mdd_start_ts,
        "mdd_end_ts": mdd_end_ts,
        "recovery_ts": recovery_ts,
        "recovery_period": recovery_period,
    }
    return nvs, dict_mdd


class Backtester:
    """Backtest Cross-sectinal Strategy

    - Notation
        - `factor` (T*N*1): final factor generated by raw features to rank stocks
        - `ret` (T*N*1): next second period return of each stock in each period
        - `pos` (T*N*1): percentage we should invest in each stock
        - `strat_ret` (T*1): return the strategy in each period
        - `nv` (T*1): net value of the strategy in each period
    - Process
        1. `factor` -> `pos`
        2. `pos` + `ret` -> `strat_ret`
        3. `strat_ret` -> `nv`
    """

    freq_to_days = {"d": 1, "w": 5, "m": 21, "q": 63, "y": 252}

    def __init__(
        self,
        factor: str,
        larger_is_better: bool = True,
        freq: str = "d",
        cost: float = 0.0002,
        top_pct: float = 0.1,
        long_only: bool = False,
        r_f: float = 0.02,
    ) -> None:
        """Initialization

        Parameters
        ----------
        factor : str
            Name of the factor to be backtested
        larger_is_better : bool, optional
            Larger factor values imply larger expected returns, by default True
        freq : str, optional
            Rebalancing frequency, chosen from ["d", "w", "m", "q", "y"]. It will change
            the daily transaction cost, and should be consistent with the factor
            frequency, by default "d"
        cost : float, optional
            Transaction cost, roughly estimated as the sum of the slippage and the
            commission, by default 0.0002
        long_only : bool, optional
            Can only long stocks, by default False
        top_pct : float, optional
            Invest stocks with factor value in the top percentile, by default 0.1
        r_f : float, optional
            Risk free return, by default 0.02
        """
        if freq not in Backtester.freq_to_days:
            raise Exception("`freq` should be chosen from ['d', 'w', 'm', 'q', 'y']")
        if top_pct > 0.5:
            raise Exception("`top_pct` should not be greater than 0.5")
        self.factor = factor
        self.larger_is_better = larger_is_better
        self.freq = freq
        self.cost = cost
        self.top_pct = top_pct
        self.long_only = long_only
        self.r_f = r_f
        self.ann_fac = 252 / Backtester.freq_to_days[freq]
        self.df: pd.DataFrame = None  # data for backtesting info
        self.strat_rets: pd.Series = None  # strategy returns
        self.strat_nvs: pd.Series = None  # strategy net values
        self.df_perf: pd.DataFrame = None  # performance of the strategy

    def _get_pos(self) -> None:
        """Get the position"""

        def cs_pos(cs_factor: pd.Series) -> pd.Series:
            """Convert factor to position in one period

            Summation of the long and short positions are both restricted to be 1

            Parameters
            ----------
            cs_factor : pd.Series
                Cross-sectional factor value of stocks (N*1)

            Returns
            -------
            pd.Series
                Cross-sectional position of stocks (N*1)
            """
            if not self.larger_is_better:
                cs_factor *= -1
            l_thresh = cs_factor.quantile(1 - self.top_pct)
            l_cond = cs_factor >= l_thresh
            pos = np.where(l_cond, 1 / l_cond.sum(), 0.0)
            if not self.long_only:
                s_thresh = cs_factor.quantile(self.top_pct)
                s_cond = cs_factor <= s_thresh
                s_pos = np.where(s_cond, -1 / s_cond.sum(), 0.0)
                pos += s_pos
            return pd.Series(pos, index=cs_factor.index)

        df = self.df.copy()
        self.df["pos"] = df[self.factor].groupby(level=0).apply(cs_pos)

    def _get_strat_ret(self):
        """Get the strategy return"""
        strat_rets = (self.df["pos"] * self.df["ret"]).groupby(level=0).sum()
        self.strat_rets = strat_rets - np.log(1 + self.cost) / self.ann_fac * 252
        self.strat_rets.iloc[0] = 0.0  # no trading on the first day

    def _get_performance(self):
        """Get the strategy performance

        - "ann_ret": annulized return
        - "ann_vol": annulized volatility
        - "mdd": maximum drawdown
        - "mdd_start_ts": start timestamp of mdd,
        - "mdd_end_ts": end timestamp of mdd,
        - "recovery_ts": timestamp of getting recovered from mdd,
        - "recovery_period": time it take to recover from the end of mdd
        - "sharpe_ratio": Sharpe ratio (ann_ret / ann_vol)
        - "calmar_ratio": Calmar ratio (ann_ret / mdd)
        """
        # calculate
        strat_rets = self.strat_rets
        ann_ret = strat_rets.mean() * self.ann_fac
        ann_vol = strat_rets.std() * self.ann_fac**0.5
        self.strat_nvs, dict_mdd = _calc_nv_mdd(strat_rets)
        sharpe_ratio = (ann_ret - self.r_f) / ann_vol
        calmar_ratio = (ann_ret - self.r_f) / abs(dict_mdd["mdd"])
        # load values
        df_perf = pd.DataFrame(columns=["performance"])
        df_perf.loc["ann_ret", "performance"] = ann_ret
        df_perf.loc["ann_vol", "performance"] = ann_vol
        for k, v in dict_mdd.items():
            df_perf.loc[k, "performance"] = v
        df_perf.loc["sharpe_ratio", "performance"] = sharpe_ratio
        df_perf.loc["calmar_ratio", "performance"] = calmar_ratio
        self.df_perf = df_perf

    def feed(self, df: pd.DataFrame) -> "Backtester":
        """Feed data

        Parameters
        ----------
        df : pd.DataFrame
            Panel data of `factor` and `ret`, `ret` should be the next period return

        Returns
        -------
        Backtester
            The backtester itself
        """
        if "ret" not in df.columns:
            raise Exception("`df` should contain a 'ret' column")
        if self.factor not in df.columns:
            raise Exception(f"`df` should contain a '{self.factor}' column")
        self.df = df[[self.factor, "ret"]]
        return self

    def run(self) -> "Backtester":
        """Run the backtest"""
        self._get_pos()
        self._get_strat_ret()
        self._get_performance()
        return self

    def report(self) -> None:
        """Report the backtesting result

        1. Print the performance of the strategy
        2. Plot the net value curve of the strategy
        """
        print(self.df_perf)
        plt.plot(self.strat_nvs)
        plt.show()
