import numpy as np
import pandas as pd
from matplotlib import pyplot as plt


class Backtester:
    """Backtest cross-sectinal strategies

    - Notation
        - `factor` (T*N*1): final factor generated by raw features to rank stocks
        - `ret` (T*N*1): next second period return of each stock in each period
        - `pos` (T*N*1): percentage we should invest in each stock
        - `strat_ret` (T*1): return the strategy in each period
        - `nv` (T*1): net value of the strategy in each period
    - Process
        1. `factor` -> `pos`
        2. `pos` + `ret` -> `strat_ret`
        3. `strat_ret` -> `nv`
    """

    freq_to_days = {"d": 1, "w": 5, "m": 21, "q": 63, "y": 252}

    def __init__(
        self,
        factor: str,
        larger_is_better: bool = True,
        freq: str = "d",
        cost: float = 0.0,
        top_pct: float = 0.1,
        long_only: bool = False,
        r_f: float = 0.0,
    ) -> None:
        """Initialization

        Parameters
        ----------
        factor : str
            Name of the factor to be backtested
        larger_is_better : bool, optional
            Larger factor values imply larger expected returns, by default True
        freq : str, optional
            Rebalancing frequency, chosen from ["d", "w", "m", "q", "y"]. It will change
            the daily transaction cost, and should be consistent with the factor
            frequency, by default "d"
        cost : float, optional
            Transaction cost, roughly estimated as the sum of the slippage and the
            commission, by default 0.0
        top_pct : float, optional
            Invest stocks with factor value in the top percentile, by default 0.1
        long_only : bool, optional
            Can only long stocks, by default False
        r_f : float, optional
            Risk free return, by default 0.0
        """
        if freq not in Backtester.freq_to_days:
            raise Exception("`freq` should be chosen from ['d', 'w', 'm', 'q', 'y']")
        if top_pct > 0.5:
            raise Exception("`top_pct` should not be greater than 0.5")
        self.factor = factor
        self.larger_is_better = larger_is_better
        self.freq = freq
        self.cost = cost
        self.top_pct = top_pct
        self.long_only = long_only
        self.r_f = r_f
        self.ann_fac = 252 / Backtester.freq_to_days[freq]
        self.df: pd.DataFrame = None  # backtesting info
        self.df_ret: pd.DataFrame = None  # return
        self.df_nv: pd.DataFrame = None  # net value
        self.df_perf: pd.DataFrame = None  # performance

    def _get_pos(self) -> None:
        """Get the position"""

        def cs_pos(cs_factor: pd.Series) -> pd.Series:
            """Convert factor to position in one period

            Summation of the long and short positions are both restricted to be 0.5

            Parameters
            ----------
            cs_factor : pd.Series
                Cross-sectional factor value of stocks (N*1)

            Returns
            -------
            pd.Series
                Cross-sectional position of stocks (N*1)
            """
            l_thresh = cs_factor.quantile(1 - self.top_pct)
            l_cond = cs_factor >= l_thresh
            if l_cond.sum() == 0:
                return pd.Series(0.0, index=cs_factor.index)
            pos = np.where(l_cond, 1 / l_cond.sum(), 0.0)
            if not self.long_only:
                s_thresh = cs_factor.quantile(self.top_pct)
                s_cond = cs_factor <= s_thresh
                s_pos = np.where(s_cond, -1 / s_cond.sum(), 0.0)
                pos += s_pos
            return pd.Series(pos, index=cs_factor.index)

        df = self.df.copy()
        if not self.larger_is_better:
            df[self.factor] *= -1
        df["pos"] = df[self.factor].groupby(level=0).apply(cs_pos) / 2
        self.df = df

    def _get_ret(self):
        """Get returns of the strategy and the market"""
        strat_rets = (self.df["pos"] * self.df["ret"]).groupby(level=0).sum()
        strat_rets -= np.log(1 + self.cost) / self.ann_fac * 252
        num_stock = self.df.index.get_level_values(1).nunique()
        mkt_rets = self.df["ret"].groupby(level=0).sum() / num_stock
        self.df_ret = pd.DataFrame()
        self.df_ret["mkt"] = mkt_rets
        self.df_ret["strat"] = strat_rets
        self.df_ret["excess"] = strat_rets - mkt_rets
        self.df_ret.iloc[0] = 0.0  # no trading on the first day

    def _get_perf(self):
        """Get performance of the strategy and the market

        - "ann_ret": annulized return
        - "ann_vol": annulized volatility
        - "mdd": maximum drawdown
        - "mdd_start_ts": start timestamp of mdd
        - "mdd_end_ts": end timestamp of mdd
        - "recovery_ts": timestamp of getting recovered from mdd
        - "recovery_period": time it take to recover from the end of mdd
        - "sharpe_ratio": Sharpe ratio (ann_ret / ann_vol)
        - "calmar_ratio": Calmar ratio (ann_ret / mdd)
        """
        df_perf = pd.DataFrame(columns=["mkt", "strat", "excess"])
        # calculate
        df_ret = self.df_ret
        ann_ret = df_ret.mean() * self.ann_fac
        ann_vol = df_ret.std() * self.ann_fac**0.5
        self.df_nv, df_mdd = _calc_nv_mdd(df_ret)
        sharpe_ratio = (ann_ret - self.r_f) / ann_vol
        calmar_ratio = (ann_ret - self.r_f) / abs(df_mdd.loc["mdd"])
        # load values
        df_perf.loc["ann_ret"] = ann_ret
        df_perf.loc["ann_vol"] = ann_vol
        df_perf = pd.concat([df_perf, df_mdd], axis=0)
        df_perf.loc["sharpe_ratio"] = sharpe_ratio
        df_perf.loc["calmar_ratio"] = calmar_ratio
        self.df_perf = df_perf

    def feed(self, df: pd.DataFrame) -> "Backtester":
        """Feed data

        Parameters
        ----------
        df : pd.DataFrame
            Panel data of `factor` and `ret`, `ret` should be future returns

        Returns
        -------
        Backtester
            The backtester itself
        """
        if "ret" not in df.columns:
            raise Exception("`df` should contain a 'ret' column")
        if self.factor not in df.columns:
            raise Exception(f"`df` should contain a '{self.factor}' column")
        self.df = df[[self.factor, "ret"]]
        return self

    def run(self) -> "Backtester":
        """Run the backtest"""
        self._get_pos()
        self._get_ret()
        self._get_perf()
        return self

    def report(self) -> None:
        """Report the backtesting result

        1. Print the performance of the strategy
        2. Plot the net value curve of the strategy
        """
        print(self.df_perf)
        plt.plot(self.df_nv, label=self.df_nv.columns)
        plt.legend()
        plt.show()


def _calc_nv_mdd(df_ret: pd.DataFrame) -> tuple[pd.DataFrame]:
    """Calculate net values and maximum drawdown

    Parameters
    ----------
    df_ret : pd.DataFrame
        Returns of assets

    Returns
    -------
    tuple[pd.DataFrame]
        pd.DataFrame
            Net values
        pd.DataFrame
            Maximum drawdown info
    """
    cols = df_ret.columns
    # net values (using simple interest)
    df_nv = 1 + df_ret.cumsum()
    # nv value rolling max
    df_nv_rolling_max = df_nv.cummax()
    # drawdown
    df_dd = (df_nv - df_nv_rolling_max) / df_nv_rolling_max
    # maximum drawdown
    mdd = df_dd.min()
    # df_mdd
    mdd_idx = ["mdd", "mdd_start_ts", "mdd_end_ts", "recovery_ts", "recovery_period"]
    df_mdd = pd.DataFrame(index=mdd_idx, columns=cols)
    df_mdd.loc["mdd"] = mdd
    for c in cols:
        # mdd key timestamps
        if mdd[c]:
            mdd_end_ts_c = df_dd[c].idxmin()
            mdd_start_ts_c = df_nv.loc[:mdd_end_ts_c, c].idxmax()
            origin_level_c = df_nv.loc[mdd_start_ts_c, c]
            recovery_c = df_nv.loc[mdd_end_ts_c:, c]
            try:
                recovery_ts_c = recovery_c[recovery_c >= origin_level_c].index[0]
                recovery_period_c = recovery_ts_c - mdd_start_ts_c
            except:
                recovery_ts_c, recovery_period_c = None, None
        else:
            mdd_start_ts_c = None
            mdd_end_ts_c = None
            recovery_ts_c = None
            recovery_period_c = None
        # load values
        df_mdd.loc["mdd_start_ts", c] = mdd_start_ts_c
        df_mdd.loc["mdd_end_ts", c] = mdd_end_ts_c
        df_mdd.loc["recovery_ts", c] = recovery_ts_c
        df_mdd.loc["recovery_period", c] = recovery_period_c
    return df_nv, df_mdd
